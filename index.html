<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ray Casting Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const context = canvas.getContext('2d');
    canvas.width = 800;
    canvas.height = 400;

    const BLACK = '#000000';
    const WHITE = '#FFFFFF';
    const RED = '#FF0000';
    const GREEN = '#00FF00';
    const YELLOW = '#FFFF00';
    const BLUE = '#0000FF';
    const PURPLE = '#800080';

    const FPS = 60;
    const angleSpeed = 0.05;
    const numRays = 120;
    const viewAngle = Math.PI / 3;
    const maxDistance = 300;
    const cooldownTime = 2000;
    const hitTime = 1000;

    let players = [
        { pos: [canvas.width / 4, canvas.height / 2], angle: 0, speed: 2, health: 3, color: RED, cooldown: 0, hitTimer: 0 },
        { pos: [3 * canvas.width / 4, canvas.height / 2], angle: 0, speed: 2, health: 3, color: BLUE, cooldown: 0, hitTimer: 0 }
    ];

    const controls = [
        { left: 'a', right: 'd', up: 'w', down: 's', turnLeft: 'q', turnRight: 'e', shoot: ' ' },
        { left: 'j', right: 'l', up: 'i', down: 'k', turnLeft: 'u', turnRight: 'o', shoot: 'm' }
    ];

    const obstacles = [
        { x: 0, y: 0, w: canvas.width, h: 10 },
        { x: 0, y: canvas.height - 10, w: canvas.width, h: 10 },
        { x: 0, y: 0, w: 10, h: canvas.height },
        { x: canvas.width - 10, y: 0, w: 10, h: canvas.height },
        { x: 100, y: 100, w: 50, h: 50 },
        { x: 300, y: 200, w: 60, h: 60 },
        { x: 150, y: 300, w: 40, h: 40 },
        { x: 500, y: 150, w: 70, h: 70 },
        { x: 600, y: 300, w: 40, h: 40 }
    ];

    const corners = [];
    for (let rect of obstacles) {
        corners.push({ x: rect.x, y: rect.y });
        corners.push({ x: rect.x + rect.w, y: rect.y });
        corners.push({ x: rect.x, y: rect.y + rect.h });
        corners.push({ x: rect.x + rect.w, y: rect.y + rect.h });
    }

    function rayCasting(playerPos, angle, players, playerIndex) {
        let x = playerPos[0];
        let y = playerPos[1];
        const dx = Math.cos(angle);
        const dy = Math.sin(angle);

        for (let distance = 0; distance < maxDistance; distance += 5) {
            x += dx * 5;
            y += dy * 5;
            for (let corner of corners) {
                if (Math.hypot(corner.x - x, corner.y - y) < 5) {
                    return [distance, true, null];
                }
            }
            for (let rect of obstacles) {
                if (x >= rect.x && x <= rect.x + rect.w && y >= rect.y && y <= rect.y + rect.h) {
                    return [distance, false, null];
                }
            }
            for (let i = 0; i < players.length; i++) {
                if (i !== playerIndex) {
                    const player = players[i];
                    if (x >= player.pos[0] - 5 && x <= player.pos[0] + 5 && y >= player.pos[1] - 5 && y <= player.pos[1] + 5) {
                        return [distance, false, player.color];
                    }
                }
            }
        }
        return [maxDistance, false, null];
    }

    function draw3DProjection(context, player, offset_x, players, playerIndex, currentTime) {
        for (let ray = 0; ray < numRays; ray++) {
            const rayAngle = player.angle - viewAngle / 2 + viewAngle * ray / numRays;
            const [distance, isCorner, playerColor] = rayCasting(player.pos, rayAngle, players, playerIndex);
            const wallHeight = canvas.height * (1 - Math.sqrt(distance / maxDistance));
            let shade = 255 - Math.floor(distance * 255 / maxDistance);
            shade = shade < 0 ? 0 : shade;
            let wallColor = `rgb(${shade}, ${shade}, ${shade})`;

            if (playerColor) {
                for (let p of players) {
                    if (p.color === playerColor && currentTime - p.hitTimer < hitTime) {
                        wallColor = PURPLE;
                        break;
                    }
                }
            } else if (isCorner) {
                wallColor = YELLOW;
            }

            context.fillStyle = wallColor;
            context.fillRect(offset_x + ray * (canvas.width / 2) / numRays, canvas.height / 2 - wallHeight / 2, (canvas.width / 2) / numRays, wallHeight);
        }
    }

    function showWinner(context, text) {
        context.fillStyle = WHITE;
        context.font = '74px Arial';
        const textWidth = context.measureText(text).width;
        context.fillText(text, (canvas.width - textWidth) / 2, canvas.height / 2);
    }

    function drawHealth(context, player, offset_x) {
        context.fillStyle = WHITE;
        context.font = '36px Arial';
        context.fillText(`Health: ${player.health}`, offset_x + 10, 40);
    }

    function gameLoop() {
        const currentTime = performance.now();

        document.onkeydown = (e) => {
            const key = e.key.toLowerCase();
            players.forEach((player, i) => {
                const control = controls[i];
                if (key === control.up) {
                    player.pos[0] += Math.cos(player.angle) * player.speed;
                    player.pos[1] += Math.sin(player.angle) * player.speed;
                } else if (key === control.down) {
                    player.pos[0] -= Math.cos(player.angle) * player.speed;
                    player.pos[1] -= Math.sin(player.angle) * player.speed;
                } else if (key === control.left) {
                    player.pos[0] += Math.sin(player.angle) * player.speed;
                    player.pos[1] -= Math.cos(player.angle) * player.speed;
                } else if (key === control.right) {
                    player.pos[0] -= Math.sin(player.angle) * player.speed;
                    player.pos[1] += Math.cos(player.angle) * player.speed;
                } else if (key === control.turnLeft) {
                    player.angle -= angleSpeed;
                } else if (key === control.turnRight) {
                    player.angle += angleSpeed;
                } else if (key === control.shoot && currentTime - player.cooldown > cooldownTime) {
                    const [distance, , playerColor] = rayCasting(player.pos, player.angle, players, i);
                    if (playerColor) {
                        players.forEach((target, j) => {
                            if (target.color === playerColor) {
                                target.health -= 1;
                                target.hitTimer = currentTime;
                                if (target.health <= 0) {
                                    showWinner(context, `Player ${i + 1} Wins!`);
                                    setTimeout(() => location.reload(), 3000);
                                }
                            }
                        });
                    }
                    player.cooldown = currentTime;
                }
            });
        };

        context.fillStyle = BLACK;
        context.fillRect(0, 0, canvas.width, canvas.height);

        draw3DProjection(context, players[0], 0, players, 0, currentTime);
        draw3DProjection(context, players[1], canvas.width / 2, players, 1, currentTime);

        drawHealth(context, players[0], 0);
        drawHealth(context, players[1], canvas.width / 2);

        context.fillStyle = WHITE;
        context.beginPath();
        context.arc(canvas.width / 4, canvas.height / 2, 3, 0, Math.PI * 2);
        context.fill();
        context.beginPath();
        context.arc(3 * canvas.width / 4, canvas.height / 2, 3, 0, Math.PI * 2);
        context.fill();

        setTimeout(gameLoop, 1000 / FPS);
    }

    gameLoop();
</script>
</body>
</html>
