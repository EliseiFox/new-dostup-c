<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebSocket Game</title>
  <style>
    canvas {
      display: block;
      margin: 0 auto;
      background: black;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="400"></canvas>
  <script>
    const ws = new WebSocket('wss://ef9a-212-58-119-152.ngrok-free.app');

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    const FPS = 60;
    const BLACK = '#000000';
    const WHITE = '#FFFFFF';
    const RED = '#FF0000';
    const BLUE = '#0000FF';
    const PURPLE = '#800080';
    const YELLOW = '#FFFF00';

    const playerId = Math.floor(Math.random() * 100000); // Генерация уникального ID для каждого игрока

    let players = {
      [playerId]: { id: playerId, pos: { x: width / 4, y: height / 2 }, angle: 0, speed: 2, health: 3, color: RED, cooldown: 0, hit_timer: 0 }
    };

    const controls = [
      { left: 'KeyA', right: 'KeyD', up: 'KeyW', down: 'KeyS', turn_left: 'KeyQ', turn_right: 'KeyE', shoot: 'Space' }
    ];

    const angle_speed = 0.05;
    const num_rays = 120;
    const view_angle = Math.PI / 3;
    const max_distance = 300;
    const cooldown_time = 2000; // Cooldown in milliseconds
    const hit_time = 1000; // Time for color change when hit

    const obstacles = [
      [0, 0, width, 10], // Top wall
      [0, height - 10, width, 10], // Bottom wall
      [0, 0, 10, height], // Left wall
      [width - 10, 0, 10, height], // Right wall
      [100, 100, 50, 50], // Obstacle
      [300, 200, 60, 60], // Obstacle
      [150, 300, 40, 40], // Obstacle
      [500, 150, 70, 70], // Obstacle
      [600, 300, 40, 40] // Obstacle
    ];

    const corners = [];
    for (let rect of obstacles) {
      corners.push([rect[0], rect[1]]);
      corners.push([rect[0] + rect[2], rect[1]]);
      corners.push([rect[0], rect[1] + rect[3]]);
      corners.push([rect[0] + rect[2], rect[1] + rect[3]]);
    }

    function ray_casting(player_pos, angle, players, player_index) {
      let { x, y } = player_pos;
      let dx = Math.cos(angle);
      let dy = Math.sin(angle);
      for (let distance = 0; distance < max_distance; distance += 5) {
        x += dx * 5;
        y += dy * 5;
        if (corners.some(corner => corner[0] === Math.floor(x) && corner[1] === Math.floor(y))) {
          return [distance, true, null];
        }
        for (let rect of obstacles) {
          if (rect[0] <= x && x <= rect[0] + rect[2] && rect[1] <= y && y <= rect[1] + rect[3]) {
            return [distance, false, null];
          }
        }
        for (let key in players) {
          if (key !== player_index.toString()) {
            let { x: px, y: py } = players[key].pos;
            if (px - 5 <= x && x <= px + 5 && py - 5 <= y && y <= py + 5) {
              return [distance, false, players[key].color];
            }
          }
        }
      }
      return [max_distance, false, null];
    }

    function draw_3d_projection(ctx, player, obstacles, players, player_index, current_time) {
      for (let ray = 0; ray < num_rays; ray++) {
        let ray_angle = player.angle - view_angle / 2 + view_angle * ray / num_rays;
        let [distance, is_corner, player_color] = ray_casting(player.pos, ray_angle, players, player_index);
        let wall_height = height * (1 - Math.sqrt(distance / max_distance));
        let shade = 255 - Math.floor(distance * 255 / max_distance);
        let wall_color;
        if (player_color) {
          for (let key in players) {
            if (players[key].color === player_color && current_time - players[key].hit_timer < hit_time) {
              player_color = PURPLE;
            }
          }
          wall_color = player_color;
        } else {
          wall_color = is_corner ? YELLOW : `rgb(${shade}, ${shade}, ${shade})`;
        }
        ctx.fillStyle = wall_color;
        ctx.fillRect(ray * (width / num_rays), height / 2 - wall_height / 2, width / num_rays, wall_height);
      }
    }

    function draw_health(ctx, player) {
      ctx.font = '36px sans-serif';
      ctx.fillStyle = WHITE;
      ctx.fillText(`Health: ${player.health}`, 10, 36);
    }

    function receiveData(event) {
      const data = JSON.parse(event.data);
      players = { ...data };
    }

    ws.addEventListener('message', receiveData);

    function sendData() {
      const player = players[playerId];
      ws.send(JSON.stringify({
        id: playerId,
        pos: player.pos,
        angle: player.angle,
        health: player.health,
        color: player.color,
        cooldown: player.cooldown,
        hit_timer: player.hit_timer,
        time: performance.now()
      }));
    }

    setInterval(sendData, 1000 / FPS);

    document.addEventListener('keydown', (event) => {
      const player = players[playerId];
      switch (event.key) {
        case 'w':
          player.pos.y -= player.speed;
          break;
        case 's':
          player.pos.y += player.speed;
          break;
        case 'a':
          player.pos.x -= player.speed;
          break;
        case 'd':
          player.pos.x += player.speed;
          break;
        case 'q':
          player.angle -= 0.05;
          break;
        case 'e':
          player.angle += 0.05;
          break;
      }
      ws.send(JSON.stringify({
        id: playerId,
        pos: player.pos,
        angle: player.angle,
        health: player.health,
        color: player.color,
        cooldown: player.cooldown,
        hit_timer: player.hit_timer,
        time: performance.now()
      }));
    });

    function gameLoop() {
      ctx.fillStyle = BLACK;
      ctx.fillRect(0, 0, width, height);

      let current_time = performance.now();

      for (let key in players) {
        if (players.hasOwnProperty(key)) {
          draw_3d_projection(ctx, players[key], obstacles, players, key, current_time);
          draw_health(ctx, players[key]);
        }
      }

      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
