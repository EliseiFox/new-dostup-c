<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ray Casting with Multiplayer</title>
    <style>
        .open-link-button {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
            background: black;
        }
        #hpDisplay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 20px;
        }
        #messageContainer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            font-size: 30px;
            text-align: center;
            display: none;
        }
    </style>
</head>
<body>
    <div id="messageContainer"></div>
    <button class="open-link-button no-select" onclick="openAnotherSite()">Open Site</button>
    <canvas id="gameCanvas"></canvas>
    <div id="hpDisplay">HP: 3</div>
    <script>
        function openAnotherSite() {
            window.open('https://458f-212-58-119-152.ngrok-free.app', '_blank');
        }

        document.addEventListener('keydown', function(event) {
            if (event.key === ' ') {
                event.preventDefault();
            }
        });

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const width = canvas.width;
        const height = canvas.height;

        const COLORS = {
            BLACK: 'black',
            YELLOW: 'yellow',
            RED: 'red',
            PURPLE: 'purple'
        };

        const player = {
            pos: { x: width / 4, y: height / 2 },
            angle: 0,
            speed: 2,
            angleSpeed: 0.02,
            hp: 3
        };

        const numRays = 500;
        const viewAngle = Math.PI / 3;
        const maxDistance = 800;
        let opponentHP = 3;
        let canShoot = true;
        let lastShotTime = 0;

        const redWall = { x: 200, y: 200, w: 30, h: 30, color: COLORS.RED };

        const obstacles = [
            { x: 0, y: 0, w: width, h: 10 },
            { x: 0, y: height - 10, w: width, h: 10 },
            { x: 0, y: 0, w: 10, h: height },
            { x: width - 10, y: 0, w: 10, h: height },
            { x: 100, y: 100, w: 50, h: 50 },
            { x: 300, y: 200, w: 60, h: 60 },
            { x: 150, y: 300, w: 40, h: 40 },
            { x: 500, y: 150, w: 70, h: 70 },
            { x: 600, y: 300, w: 40, h: 40 },
            redWall
        ];

        const corners = obstacles.flatMap(rect => [
            { x: rect.x, y: rect.y },
            { x: rect.x + rect.w, y: rect.y },
            { x: rect.x, y: rect.y + rect.h },
            { x: rect.x + rect.w, y: rect.y + rect.h }
        ]);

        function rayCasting(playerPos, angle) {
            let x = playerPos.x;
            let y = playerPos.y;
            const dx = Math.cos(angle);
            const dy = Math.sin(angle);
            for (let distance = 0; distance < maxDistance; distance++) {
                x += dx;
                y += dy;
                if (corners.some(corner => Math.abs(x - corner.x) < 1 && Math.abs(y - corner.y) < 1)) {
                    return { distance, isCorner: true };
                }
                for (let rect of obstacles) {
                    if (x >= rect.x && x <= rect.x + rect.w && y >= rect.y && y <= rect.y + rect.h) {
                        return { distance, isCorner: false, color: rect.color };
                    }
                }
            }
            return { distance: maxDistance, isCorner: false, color: null };
        }

        function draw() {
            ctx.fillStyle = COLORS.BLACK;
            ctx.fillRect(0, 0, width, height);

            const startAngle = player.angle - viewAngle / 2;

            for (let i = 0; i < numRays; i++) {
                const rayAngle = startAngle + viewAngle * i / numRays;
                const { distance, isCorner, color } = rayCasting(player.pos, rayAngle);
                const correctedDistance = distance * Math.cos(rayAngle - player.angle);
                const wallHeight = height / correctedDistance * 100;
                const shade = 255 - Math.floor(distance * 255 / maxDistance);
                ctx.fillStyle = color || (isCorner ? COLORS.YELLOW : `rgb(${shade},${shade},${shade})`);
                ctx.fillRect(i * width / numRays, height / 2 - wallHeight / 2, width / numRays, wallHeight);
            }

            ctx.fillStyle = COLORS.YELLOW;
            ctx.beginPath();
            ctx.arc(width / 2, height / 2, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        function update() {
            draw();
            requestAnimationFrame(update);
        }

        const keys = {};

        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        function checkCollision(x, y) {
            return obstacles.some(rect =>
                x >= rect.x && x <= rect.x + rect.w && y >= rect.y && y <= rect.y + rect.h
            );
        }

        function movePlayer() {
            let newPos = { x: player.pos.x, y: player.pos.y };

            if (keys['KeyW']) {
                newPos.x += player.speed * Math.cos(player.angle);
                newPos.y += player.speed * Math.sin(player.angle);
            }
            if (keys['KeyS']) {
                newPos.x -= player.speed * Math.cos(player.angle);
                newPos.y -= player.speed * Math.sin(player.angle);
            }
            if (keys['KeyA']) {
                newPos.x += player.speed * Math.cos(player.angle - Math.PI / 2);
                newPos.y += player.speed * Math.sin(player.angle - Math.PI / 2);
            }
            if (keys['KeyD']) {
                newPos.x += player.speed * Math.cos(player.angle + Math.PI / 2);
                newPos.y += player.speed * Math.sin(player.angle + Math.PI / 2);
            }

            if (!checkCollision(newPos.x, newPos.y)) {
                player.pos = newPos;
            }

            if (keys['ArrowLeft']) {
                player.angle -= player.angleSpeed;
            }
            if (keys['ArrowRight']) {
                player.angle += player.angleSpeed;
            }
        }

        function shoot() {
            if (!canShoot) return;
            canShoot = false;
            lastShotTime = Date.now();
            const { distance, color } = rayCasting(player.pos, player.angle);
            if (color === COLORS.RED) {
                socket.send(JSON.stringify({ action: 'shoot' }));
                redWall.color = COLORS.PURPLE;
                setTimeout(() => {
                    redWall.color = COLORS.RED;
                }, 1000);
            }
            setTimeout(() => {
                canShoot = true;
            }, 2000);
        }

        function checkGameOver() {
            if (player.hp <= 0) {
                displayMessage('Ты проиграл');
                setTimeout(resetGame, 3000);
            } else if (opponentHP <= 0) {
                displayMessage('Ты победил');
                setTimeout(resetGame, 3000);
            }
        }

        function displayMessage(message) {
            const messageContainer = document.getElementById('messageContainer');
            messageContainer.textContent = message.toUpperCase();
            messageContainer.style.display = 'block';
        }

        function resetGame() {
            const messageContainer = document.getElementById('messageContainer');
            messageContainer.style.display = 'none';
            player.hp = 3;
            opponentHP = 3;
            player.pos = { x: width / 4, y: height / 2 };
            player.angle = 0;
            socket.send(JSON.stringify({ action: 'reset' }));
        }

        function gameLoop() {
            movePlayer();
            draw();
            sendPosition();
            requestAnimationFrame(gameLoop);
        }

        function sendPosition() {
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ position: player.pos }));
            }
        }

        const socket = new WebSocket('wss://458f-212-58-119-152.ngrok-free.app');

        socket.onmessage = function(event) {
            const data = JSON.parse(event.data);
            redWall.x = data.wallPosition.x;
            redWall.y = data.wallPosition.y;
            if (data.playerHP !== undefined) {
                player.hp = data.playerHP;
                document.getElementById('hpDisplay').innerText = `HP: ${player.hp}`;
            }
            if (data.opponentHP !== undefined) {
                opponentHP = data.opponentHP;
            }
            checkGameOver();
        };

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                shoot();
            }
        });

        update();
        gameLoop();
    </script>
</body>
</html>
